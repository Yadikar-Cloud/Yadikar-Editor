tinymce.PluginManager.add('pageview', function(editor, url) {
    
    // A4 dimensions in pixels (at 96 DPI)
    const A4_WIDTH = 794; // 210mm
    const A4_HEIGHT = 1123; // 297mm
    const PAGE_GAP = 40; // Gap between pages
    const HORIZONTAL_PADDING = 10; // Left/right padding from borders - CHANGE THIS VALUE TO ADJUST
    
    let pageViewEnabled = true;
    let currentPageSize = 'a4';
    
    // Page size presets (in pixels at 96 DPI)
    const pageSizes = {
        a4: { width: 794, height: 1123, name: 'A4 (210 × 297 mm)' },
        letter: { width: 816, height: 1056, name: 'Letter (8.5 × 11 in)' },
        legal: { width: 816, height: 1344, name: 'Legal (8.5 × 14 in)' },
        a5: { width: 559, height: 794, name: 'A5 (148 × 210 mm)' }
    };
    
    // Add toolbar button
    editor.ui.registry.addToggleButton('pageview', {
        text: 'Page View',
        icon: 'page',
        tooltip: 'Toggle page view',
        onAction: function(api) {
            togglePageView();
            api.setActive(pageViewEnabled);
        },
        onSetup: function(api) {
            api.setActive(pageViewEnabled);
        }
    });
    
    // Add menu item
    editor.ui.registry.addMenuItem('pageview', {
        text: 'Page View',
        icon: 'page',
        onAction: function() {
            togglePageView();
        }
    });
    
    // Add page size selector
    editor.ui.registry.addMenuButton('pagesize', {
        text: 'Page Size',
        icon: 'resize',
        fetch: function(callback) {
            const items = Object.keys(pageSizes).map(key => ({
                type: 'menuitem',
                text: pageSizes[key].name,
                onAction: function() {
                    setPageSize(key);
                }
            }));
            callback(items);
        }
    });
    
    // Initialize page view on editor init
    editor.on('init', function() {
        if (pageViewEnabled) {
            applyPageView();
        }
    });
    
    // Monitor content changes and add new pages if needed
editor.on('keydown', function(e) {
    if (!pageViewEnabled) return;
    
    // Handle special keys
    if (e.key === 'Enter') {
        handleEnterKey(e);
        return;
    } else if (e.key === 'Backspace' || e.key === 'Delete') {
        handleBackspaceDelete(e);
        return;
    }
    
    // Check if this is a regular character
    if (!e.key || e.key.length !== 1 || e.ctrlKey || e.metaKey || e.altKey) {
        return;
    }
    
    // This is a regular character being typed
    // Count current total visual lines to see if we're near a page boundary
    const body = editor.getBody();
    const iframe = editor.getContentAreaContainer().querySelector('iframe');
    
    if (!iframe) return;
    
    const paragraphs = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
    const contentParagraphs = [];
    let totalVisualLines = 0;
    
    paragraphs.forEach(p => {
        if (!p.closest('#page-overlay') && !p.classList.contains('page-break-spacer')) {
            contentParagraphs.push(p);
            
            const computedStyle = iframe.contentWindow.getComputedStyle(p);
            const lineHeight = parseFloat(computedStyle.lineHeight) || 22;
            const paraHeight = p.offsetHeight;
            const visualLines = Math.max(1, Math.round(paraHeight / lineHeight));
            totalVisualLines += visualLines;
        }
    });
    
    const linesPerPage = 29;
    const linePositionInPage = (totalVisualLines - 1) % linesPerPage;
    
    console.log('KEYDOWN: Total visual lines:', totalVisualLines, 'Position:', linePositionInPage);
    
    // Check if we're on line 28 or 29 of ANY page (lines that could wrap to create a new page)
    if (linePositionInPage >= 27) {  // Line 28 or 29 (0-indexed: 27, 28)
        // Find which paragraph the cursor is in
        const selection = editor.selection;
        const currentNode = selection.getNode();
        
        // Find the paragraph containing the cursor
        let currentPara = null;
        for (let i = 0; i < contentParagraphs.length; i++) {
            if (contentParagraphs[i] === currentNode || contentParagraphs[i].contains(currentNode)) {
                currentPara = contentParagraphs[i];
                break;
            }
        }
        
        if (currentPara) {
            // Check cursor position
            const range = selection.getRng();
            const tempSpan = iframe.contentDocument.createElement('span');
            tempSpan.textContent = '|';
            
            try {
                range.insertNode(tempSpan);
                const cursorX = tempSpan.offsetLeft;
                const paraWidth = currentPara.offsetWidth;
                
                tempSpan.remove();
                
                // If we're near the right edge, next char might wrap
                const nearEndOfLine = cursorX > (paraWidth - 10);
                
                console.log('KEYDOWN: Near page boundary - Cursor X:', cursorX, 'Para width:', paraWidth, 'Near end?', nearEndOfLine);
                
                if (nearEndOfLine) {
                    // STEP 1: Prevent the character from being inserted
                    e.preventDefault();
                    const charToInsert = e.key;
                    
                    console.log('STEP 1: Prevented character "' + charToInsert + '" from being inserted (would create line 30)');
                    
                    // STEP 2: Create new page and move cursor to first line
                    const newP = editor.dom.create('p', {}, '<br>'); // Empty paragraph
                    body.appendChild(newP);
                    
                    setTimeout(() => {
                        checkAndAddPage();
                        
                        setTimeout(() => {
                            // Move cursor to beginning of new paragraph (line 1 of next page)
                            editor.selection.setCursorLocation(newP, 0);
                            
                            console.log('STEP 2: Created new page and moved cursor to first line');
                            
                            // Scroll to show the new page
                            const pageHeight = pageSizes[currentPageSize].height;
                            const currentPage = Math.floor(totalVisualLines / linesPerPage);
                            const nextPageY = currentPage * (pageHeight + PAGE_GAP);
                            
                            iframe.contentWindow.scrollTo({
                                top: nextPageY - 100,
                                behavior: 'smooth'
                            });
                            
                            setTimeout(() => {
                                // STEP 3: Insert the character at current cursor position
                                editor.selection.setContent(charToInsert);
                                
                                console.log('STEP 3: Inserted character "' + charToInsert + '" at cursor position');
                            }, 50);
                        }, 100);
                    }, 50);
                }
            } catch (err) {
                console.error('Error measuring cursor position:', err);
            }
        }
    }
});

// Use input event to detect when a new page line is created
editor.on('input', function(e) {
    if (!pageViewEnabled) return;
    
    const body = editor.getBody();
    const iframe = editor.getContentAreaContainer().querySelector('iframe');
    
    // Count paragraphs and calculate total visual lines
    const paragraphs = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
    const contentParagraphs = [];
    let totalVisualLines = 0;
    
    paragraphs.forEach(p => {
        if (!p.closest('#page-overlay') && !p.classList.contains('page-break-spacer')) {
            contentParagraphs.push(p);
            
            if (iframe) {
                const computedStyle = iframe.contentWindow.getComputedStyle(p);
                const lineHeight = parseFloat(computedStyle.lineHeight) || 22;
                const paraHeight = p.offsetHeight;
                const visualLines = Math.max(1, Math.round(paraHeight / lineHeight));
                totalVisualLines += visualLines;
            }
        }
    });
    
    const linesPerPage = 29;
    const currentPageOfLastLine = Math.floor((totalVisualLines - 1) / linesPerPage);
    const linePositionInPage = (totalVisualLines - 1) % linesPerPage;
    
    console.log('Total visual lines:', totalVisualLines, 'Position in page:', linePositionInPage, 'Page:', currentPageOfLastLine);
    
    // Check if we just created line 30, 59, 88, etc (first line of a new page)
    // linePositionInPage === 0 means we're on line 1, 30, 59, 88, etc.
    if (linePositionInPage === 0 && totalVisualLines > linesPerPage) {
        console.log('NEW PAGE LINE DETECTED! Line', totalVisualLines, 'should be on page', currentPageOfLastLine + 1);
        
        // Recalculate pages - this will put the page break in the right place
        setTimeout(() => {
            checkAndAddPage();
            
            setTimeout(() => {
                // Scroll to show the new page
                const pageHeight = pageSizes[currentPageSize].height;
                const nextPageY = currentPageOfLastLine * (pageHeight + PAGE_GAP);
                
                if (iframe) {
                    iframe.contentWindow.scrollTo({
                        top: nextPageY - 100,
                        behavior: 'smooth'
                    });
                }
            }, 100);
        }, 50);
    } else {
        // Normal recalculation
        checkAndAddPage();
    }
});

function handleEnterKey(e) {
    const body = editor.getBody();
    
    // Count lines (paragraphs and headings, exclude spacers)
    const lines = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, div.line');
    let totalLines = 0;
    
    lines.forEach(line => {
        if (!line.classList.contains('page-break-spacer') && !line.closest('#page-overlay')) {
            totalLines++;
        }
    });
    
    // A4 page with 96px padding - 29 lines fit per page
    const linesPerPage = 29;
    const currentPage = Math.floor((totalLines - 1) / linesPerPage);
    
    console.log('Total lines:', totalLines, 'Lines per page:', linesPerPage, 'Current page:', currentPage);
    
    // Check if we're on the last line of current page
    const linePositionInPage = (totalLines - 1) % linesPerPage;
    const isLastLine = linePositionInPage >= (linesPerPage - 1);
    
    console.log('Line position in page:', linePositionInPage, 'Is last line?', isLastLine);
    
    if (isLastLine) {
        // We're at the last line - add new page and move cursor
        e.preventDefault();
        
        // Insert new paragraph
        const newP = editor.dom.create('p', {}, '<br>');
        body.appendChild(newP);
        
        setTimeout(() => {
            checkAndAddPage();
            
            setTimeout(() => {
                // Calculate where the new page starts
                const pageHeight = pageSizes[currentPageSize].height;
                const nextPageNumber = currentPage + 1;
                const nextPageY = nextPageNumber * (pageHeight + PAGE_GAP);
                
                // Find the first line of the next page
                const allLines = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, div.line');
                const firstLineOfNextPage = allLines[totalLines]; // The line we just created
                
                if (firstLineOfNextPage && firstLineOfNextPage.id !== 'page-overlay') {
                    // Set cursor to beginning of the new line
                    editor.selection.setCursorLocation(firstLineOfNextPage, 0);
                    
                    // Scroll to show the new page
                    const iframe = editor.getContentAreaContainer().querySelector('iframe');
                    if (iframe) {
                        iframe.contentWindow.scrollTo({
                            top: nextPageY - 100,
                            behavior: 'smooth'
                        });
                    }
                }
            }, 100);
        }, 50);
    }
}

function handleBackspaceDelete(e) {
    const body = editor.getBody();
    const selection = editor.selection;
    const currentNode = selection.getNode();
    
    // Get cursor position
    const range = selection.getRng();
    const cursorOffset = range.startOffset;
    
    // Check if cursor is at the beginning of the element
    const isAtBeginning = cursorOffset === 0 && 
                          range.startOffset === range.endOffset;
    
    if (!isAtBeginning) return;
    
    // Count lines (exclude spacers)
    const lines = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li, div.line');
    const contentLines = [];
    
    lines.forEach(line => {
        if (!line.closest('#page-overlay') && !line.classList.contains('page-break-spacer')) {
            contentLines.push(line);
        }
    });
    
    // Find current line index
    let currentLineIndex = -1;
    for (let i = 0; i < contentLines.length; i++) {
        if (contentLines[i] === currentNode || contentLines[i].contains(currentNode)) {
            currentLineIndex = i;
            break;
        }
    }
    
    if (currentLineIndex === -1) return;
    
    const linesPerPage = 29;
    const linePositionInPage = currentLineIndex % linesPerPage;
    const isFirstLineOfPage = linePositionInPage === 0;
    const currentPage = Math.floor(currentLineIndex / linesPerPage);
    
    console.log('Backspace/Delete - Line index:', currentLineIndex, 'Position in page:', linePositionInPage, 'Is first line?', isFirstLineOfPage, 'Current page:', currentPage);
    
    // Calculate total pages
    const totalPages = Math.ceil(contentLines.length / linesPerPage);
    
    // If we're on the very first line (index 0) at the beginning, prevent default to avoid issues
    if (currentLineIndex === 0 && isAtBeginning) {
        // Only prevent if this would cause issues (e.g., only one line total)
        if (contentLines.length <= 1) {
            e.preventDefault();
            return;
        }
        // Otherwise allow normal backspace behavior to merge with previous element
        return;
    }
    
    // Only proceed if:
    // 1. We're on first line of a page
    // 2. We're not on the first page (currentPage > 0)
    // 3. There's more than one page total (totalPages > 1)
    if (isFirstLineOfPage && currentPage > 0 && totalPages > 1) {
        e.preventDefault();
        
        // Find the last line of the previous page
        const previousPageLastLineIndex = currentLineIndex - 1;
        const previousPageLastLine = contentLines[previousPageLastLineIndex];
        
        if (previousPageLastLine) {
            // Get the current line's content
            const currentLineContent = currentNode.textContent || '';
            const currentLineHTML = currentNode.innerHTML || '';
            
            // Check if current line is empty or just has a <br>
            const isCurrentLineEmpty = currentLineContent.trim() === '' || currentLineHTML === '<br>';
            
            if (isCurrentLineEmpty) {
                // If current line is empty, just remove it and move cursor to end of previous line
                const lineToRemove = contentLines[currentLineIndex];
                
                // Move cursor to end of previous line
                editor.selection.setCursorLocation(previousPageLastLine, previousPageLastLine.childNodes.length);
                
                // Remove the empty line
                lineToRemove.remove();
                
                // Recalculate pages
                setTimeout(() => {
                    checkAndAddPage();
                    
                    // Scroll to show the previous page
                    const pageHeight = pageSizes[currentPageSize].height;
                    const previousPageY = (currentPage - 1) * (pageHeight + PAGE_GAP);
                    
                    const iframe = editor.getContentAreaContainer().querySelector('iframe');
                    if (iframe) {
                        iframe.contentWindow.scrollTo({
                            top: previousPageY + pageHeight - 200,
                            behavior: 'smooth'
                        });
                    }
                }, 50);
            } else {
                // If current line has content, merge it with previous line
                const previousLineContent = previousPageLastLine.innerHTML || '';
                
                // Merge content
                previousPageLastLine.innerHTML = previousLineContent + currentLineHTML;
                
                // Move cursor to the junction point
                const cursorPosition = previousLineContent.length;
                editor.selection.setCursorLocation(previousPageLastLine, Math.min(cursorPosition, previousPageLastLine.childNodes.length));
                
                // Remove current line
                currentNode.remove();
                
                // Recalculate pages
                setTimeout(() => {
                    checkAndAddPage();
                    
                    // Scroll to show the previous page
                    const pageHeight = pageSizes[currentPageSize].height;
                    const previousPageY = (currentPage - 1) * (pageHeight + PAGE_GAP);
                    
                    const iframe = editor.getContentAreaContainer().querySelector('iframe');
                    if (iframe) {
                        iframe.contentWindow.scrollTo({
                            top: previousPageY + pageHeight - 200,
                            behavior: 'smooth'
                        });
                    }
                }, 50);
            }
        }
    }
}

// Add specific paste handler for better control
editor.on('paste', function(e) {
    if (!pageViewEnabled) return;
    
    // Allow paste to complete, then recalculate pages multiple times
    setTimeout(() => {
        checkAndAddPage();
    }, 100);
    
    setTimeout(() => {
        checkAndAddPage();
    }, 300);
    
    setTimeout(() => {
        checkAndAddPage();
    }, 500);
});

editor.on('input', function() {
    if (pageViewEnabled) {
        checkAndAddPage();
    }
});

// Handle backspace and delete to recalculate pages
editor.on('keyup', function(e) {
    if (!pageViewEnabled) return;
    
    if (e.key === 'Backspace' || e.key === 'Delete') {
        console.log('Backspace/Delete detected - recalculating pages');
        checkAndAddPage();
    }
});
    
    editor.on('input', function() {
        if (pageViewEnabled) {
            checkAndAddPage();
        }
    });
    
    function togglePageView() {
        pageViewEnabled = !pageViewEnabled;
        if (pageViewEnabled) {
            applyPageView();
        } else {
            removePageView();
        }
    }
    
    function setPageSize(size) {
        currentPageSize = size;
        if (pageViewEnabled) {
            applyPageView();
        }
        
        editor.notificationManager.open({
            text: 'Page size set to ' + pageSizes[size].name,
            type: 'success',
            timeout: 2000
        });
    }
    
function applyPageView() {
    const size = pageSizes[currentPageSize];
    
    // Inject CSS for page view (outer styles)
    const styleId = 'pageview-styles';
    let styleTag = document.getElementById(styleId);
    
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = styleId;
        document.head.appendChild(styleTag);
    }
    
    styleTag.textContent = `
        /* Darker gray background for better contrast */
        .tox-tinymce {
            background: #e8eaed !important;
        }
        
        .tox-edit-area {
            background: #e8eaed !important;
            padding: 40px 20px !important;
            display: flex !important;
            justify-content: center !important;
            overflow-y: auto !important;
            overflow-x: auto !important;
            max-height: calc(100vh - 150px) !important;
        }
        
        /* Page container */
        .tox-edit-area iframe {
            background: transparent !important;
            width: ${size.width}px !important;
            display: block !important;
            margin: 0 auto !important;
            border: none !important;
        }
        
        /* Editor body */
        .mce-content-body {
            background: white !important;
            width: ${size.width}px !important;
            margin: 0 !important;
            padding: 96px !important;
            box-sizing: border-box !important;
            overflow: visible !important;
        }
    `;
    
    // Apply styles to iframe and body
    setTimeout(() => {
        const iframe = editor.getContentAreaContainer().querySelector('iframe');
        if (!iframe) return;
        
        const html = iframe.contentDocument.documentElement;
        const body = iframe.contentDocument.body;
        const pageHeight = size.height;
        
        // Initial setup
        iframe.style.width = size.width + 'px';
        iframe.style.background = 'transparent';
        iframe.style.margin = '0 auto';
        iframe.style.display = 'block';
        iframe.style.border = 'none';
        
        html.style.overflow = 'hidden';
        
        body.style.boxSizing = 'border-box';
        body.style.padding = '96px';
        body.style.margin = '0';
        body.style.background = 'white';
        body.style.width = size.width + 'px';
        body.style.overflow = 'hidden';
        
        // Apply horizontal padding
        body.style.setProperty('padding-left', HORIZONTAL_PADDING + 'px', 'important');
        body.style.setProperty('padding-right', HORIZONTAL_PADDING + 'px', 'important');
        
        // Add page styling (inner styles)
        const oldStyle = iframe.contentDocument.getElementById('page-style');
        if (oldStyle) oldStyle.remove();
        
        const style = iframe.contentDocument.createElement('style');
        style.id = 'page-style';
style.textContent = `
    body {
        position: relative;
        background: #e8eaed !important;
        padding: 0 !important;
    }
    
    /* Make all body content appear above page overlay */
    body > *:not(#page-overlay) {
        position: relative;
        z-index: 10;
    }
`;
        iframe.contentDocument.head.appendChild(style);
        
        // Remove body borders - we'll add individual page borders
        body.style.border = 'none';
        body.style.boxShadow = 'none';
        
        // Create separate page overlays with borders
        const pageOverlay = iframe.contentDocument.createElement('div');
        pageOverlay.id = 'page-overlay';
        pageOverlay.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        `;
        
        // Add page boxes dynamically based on content
        function updatePageBoxes() {
            pageOverlay.innerHTML = '';
            const totalHeight = parseInt(body.style.height) || 0;
            const pagesCount = Math.ceil(totalHeight / (pageHeight + PAGE_GAP));
            
            for (let i = 0; i < pagesCount; i++) {
                const pageBox = iframe.contentDocument.createElement('div');
                pageBox.style.cssText = `
                    position: absolute;
                    top: ${i * (pageHeight + PAGE_GAP)}px;
                    left: 0;
                    width: ${size.width}px;
                    height: ${pageHeight}px;
                    background: white;
                    border: 1px solid #d3d3d3;
                    box-shadow: 0 2px 8px rgba(60,64,67,0.3);
                    pointer-events: none;
                `;
                pageOverlay.appendChild(pageBox);
            }
        }
        
        if (body.parentElement) {
            body.parentElement.appendChild(pageOverlay);
        }
        
        // Move overlay to be first child so content renders on top
        if (body.firstChild) {
            body.insertBefore(pageOverlay, body.firstChild);
        } else {
            body.appendChild(pageOverlay);
        }
        
        // Store reference for updates
        iframe.contentWindow.updatePageBoxes = updatePageBoxes;
        updatePageBoxes();
        
        // Initial page calculation
        checkAndAddPage();
    }, 100);
}
    
    function removePageView() {
        const styleTag = document.getElementById('pageview-styles');
        if (styleTag) {
            styleTag.remove();
        }
        
        const iframeDoc = editor.getDoc();
        if (iframeDoc) {
            const iframeStyle = iframeDoc.getElementById('pageview-iframe-styles');
            if (iframeStyle) {
                iframeStyle.remove();
            }
        }
    }
    
function checkAndAddPage() {
    if (!pageViewEnabled) return;
    
    setTimeout(() => {
        const iframe = editor.getContentAreaContainer().querySelector('iframe');
        if (!iframe) return;
        
        const html = iframe.contentDocument.documentElement;
        const body = iframe.contentDocument.body;
        const size = pageSizes[currentPageSize];
        const pageHeight = size.height;
        
        // First, remove all existing spacers
        const allSpacers = body.querySelectorAll('.page-break-spacer');
        allSpacers.forEach(spacer => spacer.remove());
        
        // Count visual lines across all paragraphs
        const paragraphs = body.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li');
        const contentParagraphs = [];
        let totalVisualLines = 0;
        let visualLinesSoFar = 0;
        
        paragraphs.forEach(p => {
            if (!p.closest('#page-overlay') && !p.classList.contains('page-break-spacer')) {
                contentParagraphs.push(p);
                
                const computedStyle = iframe.contentWindow.getComputedStyle(p);
                const lineHeight = parseFloat(computedStyle.lineHeight) || 22;
                const paraHeight = p.offsetHeight;
                const visualLines = Math.max(1, Math.round(paraHeight / lineHeight));
                
                p.setAttribute('data-visual-lines', visualLines);
                totalVisualLines += visualLines;
            }
        });
        
        const linesPerPage = 29;
        const pagesNeeded = Math.max(1, Math.ceil(totalVisualLines / linesPerPage));
        
        console.log('Total visual lines:', totalVisualLines, 'Lines per page:', linesPerPage, 'Pages needed:', pagesNeeded);
        
        // Add page break dividers based on visual line count
        visualLinesSoFar = 0;
        contentParagraphs.forEach((para, index) => {
            // Remove any margins
            para.style.marginTop = '';
            para.style.marginBottom = '';
            
            const visualLines = parseInt(para.getAttribute('data-visual-lines') || '1');
            const lineNumberBefore = visualLinesSoFar;
            visualLinesSoFar += visualLines;
            const lineNumberAfter = visualLinesSoFar;
            
            // Check if this paragraph crosses a page boundary
            const pageBefore = Math.floor(lineNumberBefore / linesPerPage);
            const pageAfter = Math.floor((lineNumberAfter - 1) / linesPerPage);
            
            // If paragraph ends exactly on line 29, 58, 87, etc., insert spacer after it
            if (lineNumberAfter % linesPerPage === 0 && lineNumberAfter < totalVisualLines) {
                const spacer = iframe.contentDocument.createElement('div');
                spacer.className = 'page-break-spacer';
                spacer.contentEditable = 'false';
                spacer.style.cssText = `
                    height: ${PAGE_GAP}px;
                    user-select: none;
                    pointer-events: none;
                    margin: 0;
                    padding: 0;
                    background: transparent;
                    display: block;
                `;
                
                if (para.nextSibling) {
                    para.parentNode.insertBefore(spacer, para.nextSibling);
                } else {
                    para.parentNode.appendChild(spacer);
                }
            }
            // If paragraph spans across page boundary, insert spacer after it
            else if (pageBefore < pageAfter) {
                const spacer = iframe.contentDocument.createElement('div');
                spacer.className = 'page-break-spacer';
                spacer.contentEditable = 'false';
                spacer.style.cssText = `
                    height: ${PAGE_GAP}px;
                    user-select: none;
                    pointer-events: none;
                    margin: 0;
                    padding: 0;
                    background: transparent;
                    display: block;
                `;
                
                if (para.nextSibling) {
                    para.parentNode.insertBefore(spacer, para.nextSibling);
                } else {
                    para.parentNode.appendChild(spacer);
                }
            }
        });
        
        // Total height with gaps
        const totalHeight = (pageHeight * pagesNeeded) + (PAGE_GAP * Math.max(0, pagesNeeded - 1));
        
        // Update heights
        iframe.style.setProperty('height', totalHeight + 'px', 'important');
        html.style.height = totalHeight + 'px';
        html.style.overflow = 'hidden';
        body.style.height = totalHeight + 'px';
        body.style.minHeight = totalHeight + 'px';
        body.style.overflow = 'hidden';
        
        // Update page boxes
        if (iframe.contentWindow.updatePageBoxes) {
            iframe.contentWindow.updatePageBoxes();
        }
    }, 50);
}
    
    // Save settings
    window.getPageViewSettings = function() {
        return {
            enabled: pageViewEnabled,
            pageSize: currentPageSize
        };
    };
    
    window.setPageViewSettings = function(settings) {
        pageViewEnabled = settings.enabled !== false;
        currentPageSize = settings.pageSize || 'a4';
        if (pageViewEnabled) {
            applyPageView();
        }
    };
    
    return {
        getMetadata: function() {
            return {
                name: 'Page View',
                url: 'http://yoursite.com'
            };
        }
    };
});
