tinymce.PluginManager.add('exportpdf', function(editor, url) {
	const FONT_REGISTRY = {
		"UKIJEkranRegular": "/editor/fonts/UKIJEkranRegular.ttf",
		"UKIJChiwerKesmeRegular": "/editor/fonts/UKIJKesme.ttf",
		"UKIJCJKRegular": "/editor/fonts/UKIJCJK.ttf",
		"UKIJKufiRegular": "/editor/fonts/UKIJKu.ttf"
	}; 
	
    // Add button to toolbar
    editor.ui.registry.addButton('exportpdf', {
        text: 'Export as PDF',
        icon: 'image',
        tooltip: 'Export as PDF',
        onAction: async function() {
            generatePDF();
        }
    });

    // Add menu item
    editor.ui.registry.addMenuItem('exportpdf', {
        text: 'Export as PDF',
        icon: 'image',
        onAction: async function() {
            generatePDF();
        }
    });
	
	function getFontsUsed(root) {
		const fonts = new Set();

		root.querySelectorAll("*").forEach(el => {
		    const style = window.getComputedStyle(el);
		    const family = style.fontFamily.split(",")[0].replace(/['"]/g, "").trim();
		    if (family) fonts.add(family);
		});

		return [...fonts];
	}
	
	async function fontToBase64(url) {
		const res = await fetch(url);
		const buffer = await res.arrayBuffer();

		let binary = "";
		const bytes = new Uint8Array(buffer);
		const len = bytes.byteLength;

		for (let i = 0; i < len; i++) {
		    binary += String.fromCharCode(bytes[i]);
		}

		return btoa(binary);
	}
	
	async function getSystemFontBase64(family) {
		if (!window.queryLocalFonts) return null;
		const font = (await window.queryLocalFonts()).find(f => f.fullName === family);
		if (!font) return null;
		const blob = await font.blob();
		return await new Promise(r => {
		    const fr = new FileReader();
		    fr.onloadend = () => r(fr.result.split(",")[1]);
		    fr.readAsDataURL(blob);
		});
	}
		
	async function registerFonts(doc, fonts) {
		for (const family of fonts) {
		    const url = FONT_REGISTRY[family];
		    if (url) {
		    	// get hosted fonts
				const base64 = await fontToBase64(url);

				doc.addFileToVFS(family + ".ttf", base64);
				doc.addFont(family + ".ttf", family, "normal");
		    } else {
		    	// get system fonts
		        const base64 = await getSystemFontBase64(family);
		        if (base64) {
		            doc.addFileToVFS(family + ".ttf", base64);
		            doc.addFont(family + ".ttf", family, "normal");
		        } else {
		            console.warn(`Font ${family} not found on system`);
		        }		    	
		    }
		}
	}	
	
	async function generatePDF() {
		const { jsPDF } = window.jspdf;
		var doc = new jsPDF();
		var source = editor.getContent();
		// Register font in jsPDF vFS
		const fonts = getFontsUsed(source);
		await registerFonts(doc, fonts);
		doc.html(source, {
			callback: function(doc) {
				doc.output("dataurlnewwindow");
			},
			x: 15,
			y: 15,
			width: 180,
			windowWidth: 512,

			html2canvas: {
				ignoreElements: function (element) {
				    return element.id === "ignorePDF";
				},		
				onclone: function(clonedDoc) {
				    // 1️⃣ Disable default bullets ONLY in cloned DOM
				    const style = clonedDoc.createElement("style");
				    style.innerHTML = `
				        ul { list-style: none !important; padding-right: 1.2em; }
				    `;
				    clonedDoc.head.appendChild(style);

				    // 2️⃣ Inject manual bullets
				    clonedDoc.querySelectorAll("li").forEach(li => {
				        if (!li.dataset.bulletAdded) {
				            li.innerHTML = "• " + li.innerHTML;
				            li.dataset.bulletAdded = "true";
				        }
				    });
				}
			}
		});
	}	

    return {
        getMetadata: function() {
            return {
                name: 'Export as PDF',
                url: 'http://yoursite.com'
            };
        }
    };
});
