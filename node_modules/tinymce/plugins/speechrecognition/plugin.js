/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.9 (2023-11-15)
 */
(function () {
    'use strict';

    var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };
    var hasOwnProperty = Object.hasOwnProperty;
    var isEmpty = function (r) {
      for (var x in r) {
        if (hasOwnProperty.call(r, x)) {
          return false;
        }
      }
      return true;
    };
    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
        
	var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');
		
    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.URI');

    var global = tinymce.util.Tools.resolve('tinymce.util.XHR');

		var speechRecognitionEvents = 'SpeechRecognitionStart SpeechRecognitionEnd';
		
    var fireSpeechRecognitionStart = function (editor) {
      return editor.fire('SpeechRecognitionStart');
    };
    var fireSpeechRecognitionEnd = function (editor) {
      return editor.fire('SpeechRecognitionEnd');
    };
    
    var getLanguages = function (editor) {
      var defaultLanguages = 'English=en,Danish=da,Dutch=nl,Finnish=fi,French=fr_FR,German=de,Italian=it,Polish=pl,Portuguese=pt_BR,Spanish=es,Swedish=sv';
      return editor.getParam('webspeechapi_languages', defaultLanguages);
    };
    var getLanguage = function (editor) {
      var defaultLanguage = editor.getParam('language', 'en-US');
      return editor.getParam('webspeechapi_language', defaultLanguage);
    };

		var startSpeechRecognition = function (editor, startedState, currentLanguageState, SpeechRecognition) {
			const recognizer = new SpeechRecognition();
			let isListening = false; // ADD THIS LINE - tracks if user wants to listen

			recognizer.addEventListener('result', (event) => {
				for (let i = event.resultIndex, len = event.results.length; i < len; i++) {
				  if (event.results[i].isFinal) {
				  	tinymce.activeEditor.insertContent(event.results[i][0].transcript);
				    // confidence.value = event.results[i][0].confidence;
				  } else {
				    tinymce.activeEditor.insertContent(event.results[i][0].transcript);
				  }
				}
			});

			recognizer.addEventListener('error', (event) => {
				// logEvent`Recognition error: ${event.message}`;
			});

			recognizer.addEventListener('end', () => {
				// logEvent('Recognition ended');
				// ADD THESE LINES - auto-restart if still listening
				if (isListening) {
				  try {
				    recognizer.start();
				    // logEvent('Recognition auto-restarted');
				  } catch (error) {
				    // logEvent`Auto-restart error: ${error.message}`;
				  }
				}
			});
			
			var startRecognition = function () {
				//console.log("SpeechRecognition Start event detected");
				const isInterim = false;
				recognizer.lang = currentLanguageState.get();
				recognizer.continuous = !isInterim;
				recognizer.interimResults = isInterim;
				try {
					recognizer.start();
					// logEvent('Recognition started');
				} catch (error) {
					// logEvent`Recognition error: ${error.message}`;
				}
			}
			
			editor.on('SpeechRecognitionStart', startRecognition);
			
			var stopRecognition = function () {
				//console.log("SpeechRecognition End event detected");
				recognizer.stop();
				// logEvent('Recognition stopped');
			}
			
			editor.on('SpeechRecognitionEnd', stopRecognition); 			
		}
 
    var buildMenuItems = function (listName, languageValues) {
      var items = [];
      global$2.each(languageValues, function (languageValue) {
        items.push({
          selectable: true,
          text: languageValue.name,
          data: languageValue.value
        });
      });
      return items;
    };
    
    var get = function (editor, startedState, currentLanguageState) {
      var markErrors$1 = function (data) {
        markErrors(editor, startedState, data);
      };
      return {
        markErrors: markErrors$1,
        getLanguage: currentLanguageState.get
      };
    };
    
    var getItems = function (editor) {
      return global$2.map(getLanguages(editor).split(','), function (langPair) {
        var langPairs = langPair.split('=');
        return {
          name: langPairs[0],
          value: langPairs[1]
        };
      });
    };
    
    var register = function (editor, startedState, currentLanguageState) {
      var languageMenuItems = buildMenuItems('Language', getItems(editor));
      var speechRecognitionController = function () {
      	if(startedState.get())
      	{
      		startedState.set(false);
      		fireSpeechRecognitionEnd(editor);
      	}
      	else
      	{
      		startedState.set(true);
      		fireSpeechRecognitionStart(editor);
      	}
      };
      var buttonArgs = {
        tooltip: 'Speech Recognition',
        onAction: speechRecognitionController,
        icon: 'microphone',
        onSetup: function (buttonApi) {
        	buttonApi.setActive(startedState.get());
          var setButtonState = function () {
            buttonApi.setActive(startedState.get());
          };
          editor.on(speechRecognitionEvents, setButtonState);
          return function () {
            editor.off(speechRecognitionEvents, setButtonState);
          };
        }
      };
      var splitButtonArgs = __assign(__assign({}, buttonArgs), {
        type: 'splitbutton',
        select: function (value) {
          return value === currentLanguageState.get();
        },
        fetch: function (callback) {
          var items = global$2.map(languageMenuItems, function (languageItem) {
            return {
              type: 'choiceitem',
              value: languageItem.data,
              text: languageItem.text
            };
          });
          callback(items);
        },
        onItemAction: function (splitButtonApi, value) {
          currentLanguageState.set(value);
        }
      });
      if (languageMenuItems.length > 1) {
        editor.ui.registry.addSplitButton('speechrecognition', splitButtonArgs);
      } else {
        editor.ui.registry.addToggleButton('speechrecognition', buttonArgs);
      }
      editor.ui.registry.addToggleMenuItem('speechrecognition', {
        text: 'Speech Recognition',
        icon: 'microphone',
        onSetup: function (menuApi) {
        	menuApi.setActive(startedState.get());
          var setMenuItemCheck = function () {
            menuApi.setActive(startedState.get());
          };
          editor.on(speechRecognitionEvents, setMenuItemCheck);
          return function () {
            editor.off(speechRecognitionEvents, setMenuItemCheck);
          };
        },
        onAction: speechRecognitionController
      });
    };

    function Plugin () {
      global$3.add('speechrecognition', function (editor) {
			var startedState = Cell(false);
			var currentLanguageState = Cell(getLanguage(editor));
			const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
			
			register(editor, startedState, currentLanguageState);
			startSpeechRecognition(editor, startedState, currentLanguageState, SpeechRecognition);
			return get(editor, startedState, currentLanguageState);
      });
    }

    Plugin();

}());
